<?php

class VO_Social {
	const _ECP = 'SOC';	// Error Code Prefix
	
	/**
	 *
	 * @param WOOOF $wo
	 * @param VO_TblUserBookmarks $obj
	 * @param bool $fetchBack
	 * @return false | type of bookmarked object
	 * Returns actually saved $obj if $fetchBack is set to true
	 */
	public static
	function saveUserBookmark( WOOOF $wo, VO_TblUserBookmarks &$obj, $fetchBack=true )
	{
		$place = __CLASS__ . '::' . __FUNCTION__;
		$wo->debug( "$place:  " );
			
		if ( !$wo->hasContent($obj->voiceUserId) ) {
			$wo->logError(self::_ECP."3001 No value provided for [voiceUserId]" );
			return false;
		}
	
		if ( !$wo->hasContent($obj->thisId) ) {
			$wo->logError(self::_ECP."3002 No value provided for [thisId]" );
			return false;
		}
	
		if($obj->voiceUserId === $obj->thisId) {
			$wo->logError(self::_ECP."3003 Id's cannot be the same");
			return false;
		}
	
		$tblUserBookmark = new WOOOF_dataBaseTable($wo->db, 'voice_user_bookmarks');
		if($tblUserBookmark === FALSE) { return false; }
	
		// insert
		$obj->createdDateTime = WOOOF::currentGMTDateTime();
			
		$newId = $tblUserBookmark->insertRowFromArraySimple( $obj->toArray() );
		if ( $newId === FALSE ) { return false; }
		$obj->id = $newId;
	
		if ( $fetchBack ) {
			// Get back into $obj based on id
			// TODO:
		}
			
		return $obj->targetType;
	
	}	// saveUserBookmark
	
	/***************************************************************************/
	//
	/***************************************************************************/
	
	/**
	 *
	 * @param WOOOF $wo
	 * @param VO_TblUserFollow $obj
	 * @param bool $fetchBack
	 * @return false | id
	 * Returns actually saved $obj if $fetchBack is set to true
	 */
	public static
	function saveUserFollow( WOOOF $wo, VO_TblUserFollow &$obj, $fetchBack=true )
	{
		$place = __CLASS__ . '::' . __FUNCTION__;
		$wo->debug( "$place:  " );
		 
		if ( !$wo->hasContent($obj->followsId) ) {
			$wo->logError(self::_ECP."1001 No value provided for [followsId]" );
			return false;
		}
		
		if ( !$wo->hasContent($obj->thisId) ) {
			$wo->logError(self::_ECP."1002 No value provided for [thisId]" );
			return false;
		}
		
		if($obj->followsId === $obj->thisId) {
			$wo->logError(self::_ECP."1003 Id's cannot be the same");
			return false;
		}
		
		$tblUserFollow = new WOOOF_dataBaseTable($wo->db, 'voice_user_followings');
		if($tblUserFollow === FALSE) { return false; }
		
		// insert
		$obj->createdDateTime = WOOOF::currentGMTDateTime();
		
		//Check for Peers
		$fromId = $obj->followsId;
		$toId = $obj->thisId;
		
		$res = $tblUserFollow->getResult(
			[
				'followsId' => $toId,
				'thisId'	=> $fromId
			],
			'', '', '', '', false, true
		);
		
		if ( $res === FALSE ) { return false; }
		
		$hasPeer = $res['totalRows'] != 0; 
		
		if(!$hasPeer) {
			$obj->isPeer = '0';
		}
		
		else {
			$obj->isPeer = '1';
			foreach( $tblUserFollow->resultRows as &$aRow ) {
				$aRow['isPeer'] = '1';
				$res = $tblUserFollow->updateRowFromResults($aRow['id']);
				if($res === FALSE) { return false; }
			}
		}
			
		$newId = $tblUserFollow->insertRowFromArraySimple( $obj->toArray() );
		if ( $newId === FALSE ) { return false; }
		$obj->id = $newId;
		
		if ( $obj->targetType == 'PRS' ) {
			$usActId = VO_Users::saveAction($wo, 'FU1', $obj->thisId, null, null, $obj->followsId );
		}
		elseif ( $obj->targetType == 'ORG' ) {
			$usActId = VO_Users::saveAction($wo, 'FO1', null, $obj->thisId, null, $obj->followsId );
		}
		
		if ( $fetchBack ) {
			// Get back into $obj based on id
			// TODO:
		}
			
		return $obj->id;
		
	}	// saveUserFollow
	
	/***************************************************************************/
	//
	/***************************************************************************/
	
	/**
	 *
	 * @param WOOOF $wo
	 * @param VO_TblUserFriendRequests $obj
	 * @param bool $fetchBack
	 * @return false | id
	 * Returns actually saved $obj if $fetchBack is set to true
	 */
	public static
	function saveUserFriendRequests( WOOOF $wo, VO_TblUserFriendRequests &$obj, $fetchBack=true )
	{
		$place = __CLASS__ . '::' . __FUNCTION__;
		$wo->debug( "$place:  " );
	
		if ( !$wo->hasContent($obj->fromUserId) ) {
			$wo->logError(self::_ECP."1011 No value provided for [fromUserId]" );
			return false;
		}
			
		if ( !$wo->hasContent($obj->toUserId) ) {
			$wo->logError(self::_ECP."1012 No value provided for [toUserId]" );
			return false;
		}
			
		if($obj->fromUserId === $obj->toUserId) {
			$wo->logError(self::_ECP."1013 Id's cannot be the same");
			return false;
		}
			
		$tblFriendRequest = new WOOOF_dataBaseTable($wo->db, 'voice_user_friend_requests');
		if($tblFriendRequest === FALSE) { return false; }
		
		if ( $wo->hasContent($obj->id) ) {
			// update
			$res = $tblFriendRequest->updateRowFromArraySimple( $obj->toArray() );
			if ( $res === FALSE ) { return FALSE; }
		}

		else {
			// insert
			$obj->statusDateTime = WOOOF::currentGMTDateTime();
			$obj->status = 'P';
			
			$newId = $tblFriendRequest->insertRowFromArraySimple( $obj->toArray() );
			if ( $newId === FALSE ) { return false; }
			$obj->id = $newId;
		}

		if ( $fetchBack ) {
			// Get back into $obj based on id
			// TODO:
		}
		
		$usActId = VO_Users::saveAction(
			$wo, 'FR1', $obj->toUserId,
			null, null, $obj->fromUserId
		);
			
		return $obj->id;
	
	}	// saveUserFriendRequests
	
	/***************************************************************************/
	//
	/***************************************************************************/
	
	/**
	 *
	 * @param WOOOF $wo
	 * @param VO_TblUserFriendships $obj
	 * @param bool $fetchBack
	 * @return false | id
	 * Returns actually saved $obj if $fetchBack is set to true
	 */
	public static
	function saveUserFriendships( WOOOF $wo, VO_TblUserFriendships &$obj, $fetchBack=true )
	{
		$place = __CLASS__ . '::' . __FUNCTION__;
		$wo->debug( "$place:  " );
	
		if ( !$wo->hasContent($obj->thisId) ) {
			$wo->logError(self::_ECP."1021 No value provided for [thisId]" );
			return false;
		}
			
		if ( !$wo->hasContent($obj->isFriendsWithId) ) {
			$wo->logError(self::_ECP."1022 No value provided for [isFriendsWithId]" );
			return false;
		}
		
		if($obj->thisId === $obj->isFriendsWithId) {
			$wo->logError(self::_ECP."1003 Id's cannot be the same");
			return false;
		}

		$tblFriendship = new WOOOF_dataBaseTable($wo->db, 'voice_user_friendships');
		if($tblFriendship === FALSE) { return false; }
		
		$obj->createdDateTime = WOOOF::currentGMTDateTime();
			
		$newId = $tblFriendship->insertRowFromArraySimple( $obj->toArray() );
		if ( $newId === FALSE ) { return false; }
		$obj->id = $newId;
		
		return $obj->id;
	
	}	// saveUserFriendships
	
	/***************************************************************************/
	//
	/***************************************************************************/
	
	/**
	 *
	 * @param WOOOF $wo
	 * @param string $id for record to be deleted
	 * @return bool
	 */
	public static
	function deleteUserBookmark( WOOOF $wo, $id )
	{
		$place = __CLASS__ . '::' . __FUNCTION__;
		$wo->debug( "$place:  " );
			
		if ( !$wo->hasContent($id) ) {
			$wo->logError(self::_ECP."1909 No value provided for [id]" );
			return false;
		}
	
		$tblUserBookmark = new WOOOF_dataBaseTable($wo->db, 'voice_user_bookmarks');
		if($tblUserBookmark === FALSE) { return false; }
	
		$res = $tblUserBookmark->deleteRow($id);
		if($res === FALSE) { return false; }
			
		return $id;
	
	}	// deleteUserBookmark
	
	/***************************************************************************/
	//
	/***************************************************************************/
	
	/**
	 *
	 * @param WOOOF $wo
	 * @param string $id for record to be deleted
	 * @return bool
	 */
	public static
	function deleteUserFollow( WOOOF $wo, $id )
	{
		$place = __CLASS__ . '::' . __FUNCTION__;
		$wo->debug( "$place:  " );
			
		if ( !$wo->hasContent($id) ) {
			$wo->logError(self::_ECP."1159 No value provided for [id]" );
			return false;
		}
		
		$tblUserFollow = new WOOOF_dataBaseTable($wo->db, 'voice_user_followings');
		if($tblUserFollow === FALSE) { return false; }
		
		$rowToDelete = $tblUserFollow->getRow($id, true, false );
		if ( $rowToDelete === FALSE ) { return FALSE; }
		if ( $rowToDelete === NULL ) {
			$wo->logError(self::_ECP."1163 No voice_user_followings with id [$id] was found");
			return false;
		}
		
		$res = $tblUserFollow->deleteRow($id);
		if($res === FALSE) { return false; }
		
		// Save action
		if ( $rowToDelete['targetType'] == 'PRS' ) {
			$usActId = VO_Users::saveAction(
				$wo, 'FU2',
				$rowToDelete['thisId'], null, null, $rowToDelete['followsId']
			);
		}
		elseif ( $rowToDelete['targetType'] == 'ORG' ) {
			$usActId = VO_Users::saveAction(
				$wo, 'FO2',
				null, $rowToDelete['thisId'], null, $rowToDelete['followsId']
			);
					
		}
		
		return $id;
		
	}	// deleteUserFollow
	
	/***************************************************************************/
	//
	/***************************************************************************/
	
	
	/**
	 *
	 * @param WOOOF $wo
	 * @param string $id for record to be deleted
	 * @param bool $saveAction	// optional, default true. call VO_Users::saveAction or not.
	 * @return bool
	 */
	public static
	function deleteUserFriendRequests( WOOOF $wo, $id, $saveAction = true )
	{
		$place = __CLASS__ . '::' . __FUNCTION__;
		$wo->debug( "$place:  " );
			
		if ( !$wo->hasContent($id) ) {
			$wo->logError(self::_ECP."1160 No value provided for [id]" );
			return false;
		}
	
		$tblFriendRequest = new WOOOF_dataBaseTable($wo->db, 'voice_user_friend_requests');
		if($tblFriendRequest === FALSE) { return false; }

		if ( $saveAction ) {
			$rowToDelete = $tblFriendRequest->getRow($id, true, false );
			if ( $rowToDelete === FALSE ) { return FALSE; }
			if ( $rowToDelete === NULL ) {
				$wo->logError(self::_ECP."1163 No voice_user_friend_requests with id [$id] was found");
				return false;
			}
		}
				
		$res = $tblFriendRequest->deleteRow($id);
		if($res === FALSE) { return false; }
		
		if ( $saveAction ) {
			$usActId = VO_Users::saveAction(
				$wo, 'FR5', $rowToDelete['toUserId'],
				null, null, $rowToDelete['fromUserId']
			);
		}
				
		return $id;
	
	}	// deleteUserFriendRequests
	
	/***************************************************************************/
	//
	/***************************************************************************/
	
	/**
	 *
	 * @param WOOOF $wo
	 * @param string $id for record to be deleted
	 * @return bool
	 */
	public static
	function deleteUserFriendships( WOOOF $wo, $id )
	{
		$place = __CLASS__ . '::' . __FUNCTION__;
		$wo->debug( "$place:  " );
			
		if ( !$wo->hasContent($id) ) {
			$wo->logError(self::_ECP."1161 No value provided for [id]" );
			return false;
		}
	
		$tblFriendship = new WOOOF_dataBaseTable($wo->db, 'voice_user_friendships');
		if($tblFriendship === FALSE) { return false; }

		$rowToDelete = $tblFriendship->getRow($id, true, false );
		if ( $rowToDelete === FALSE ) { return FALSE; }
		if ( $rowToDelete === NULL ) {
			$wo->logError(self::_ECP."1163 No voice_user_friend_requests with id [$id] was found");
			return false;
		}
		
		$res = $tblFriendship->deleteRow($id);
		if($res === FALSE) { return false; }

		$otherId = ( $rowToDelete['isFriendsWithId'] == $wo->app->userId ? $rowToDelete['thisId'] : $rowToDelete['isFriendsWithId'] );
		$usActId = VO_Users::saveAction(
			$wo, 'FR4', $otherId,
			null, null, $wo->app->userId
		);
		
		return $id;
	
	}	// deleteUserFriendships
	
	/***************************************************************************/
	//
	/***************************************************************************/
  
	/**
	 * 
	 * @param WOOOF $wo
	 * @param id $fromUserId
	 * @param id $toUserId
	 * @return false | id
	 * Returns actually saved $obj if $fetchBack is set to true
	 */
	public static 
	function userFollows( WOOOF $wo, $fromUserId, $toUserId, $targetType='PRS' )
	{
		$place = __CLASS__ . '::' . __FUNCTION__;
		$wo->debug( "$place:  " );
		
		$tblUserFollowInsert = new VO_TblUserFollow();
		$tblUserFollowInsert->followsId = $fromUserId;
		$tblUserFollowInsert->thisId = $toUserId;
		$tblUserFollowInsert->targetType = $targetType;
		
		$res = self::saveUserFollow($wo, $tblUserFollowInsert);
		if($res === FALSE) { return false; }
		
		return $res;
		
	}	// userFollows
	
	/***************************************************************************/
	//
	/***************************************************************************/
	
	/**
	 *
	 * @param WOOOF $wo
	 * @param id $fromUserId
	 * @param id $toUserId
	 * @return false | id
	 * Returns actually saved $obj if $fetchBack is set to true
	 */
	public static
	function userUnFollows( WOOOF $wo, $fromUserId, $toUserId )
	{
		$place = __CLASS__ . '::' . __FUNCTION__;
		$wo->debug( "$place:  " );
		
		//Find the ID you want to delete
		$sql =  "select id ";
		$sql .=	"from voice_user_followings ";
		$sql .= "where followsId = '$fromUserId' and thisId = '$toUserId' ";
		
		$deleteRow = $wo->db->getResultByQuery($sql, true, false);
		if ( $deleteRow === FALSE ) { return FALSE; }
		
		$deleteRow = $wo->db->resultRows;
		
		foreach( $deleteRow as $aRow ) {
			$res = self::deleteUserFollow($wo, $aRow['id']);
			if($res === FALSE) { return false; }
		}
		
		//After the delete check if they were peers so as to update the isPeer value to '0'
		$sql =  "select * ";
		$sql .=	"from voice_user_followings ";
		$sql .= "where followsId = '$toUserId' and thisId = '$fromUserId' ";
		
		$rows = $wo->db->getResultByQuery($sql, true, false);
		if ( $rows === FALSE ) { return FALSE; }
		
		$rows = $wo->db->resultRows;
		
		foreach( $rows as $aRow ) {
			$tblUserFollowUpdate = new VO_TblUserFollow($aRow);
			$tblUserFollowUpdate->isPeer = '0';
			$tblUserFollow = new WOOOF_dataBaseTable($wo->db, 'voice_user_followings');
			if($tblUserFollow === FALSE) { return false; }
			$res = $tblUserFollow->updateRowFromArraySimple( $tblUserFollowUpdate->toArray() );
			if($res === FALSE) { return false; }
		}
		
		return $res;
	
	}	// userUnFollows
	
	/***************************************************************************/
	//
	/***************************************************************************/
	
	/**
	 *
	 * @param WOOOF $wo
	 * @param id $fromUserId
	 * @param id $toUserId
	 * @return false | id
	 * Returns actually saved $obj if $fetchBack is set to true
	 */
	public static
	function userRequestFriendship( WOOOF $wo, $fromUserId, $toUserId )
	{
		$place = __CLASS__ . '::' . __FUNCTION__;
		$wo->debug( "$place:  " );
	
		$tblUserFriendRequest = new VO_TblUserFriendRequests();
		$tblUserFriendRequest->fromUserId = $fromUserId;
		$tblUserFriendRequest->toUserId = $toUserId;
		
		$res = self::saveUserFriendRequests($wo, $tblUserFriendRequest);
		if($res === FALSE) { return false; }
		
		return $res;
	
	}	// userRequestFriendship
	
	/***************************************************************************/
	//
	/***************************************************************************/
	
	/**
	 *
	 * @param WOOOF $wo
	 * @param id $requestId
	 * @param char $reply ('A' accept, 'R' reject)
	 * @return false | id
	 * Returns actually saved $obj if $fetchBack is set to true
	 */
	public static
	function userAnswerFriendShip( WOOOF $wo, $requestId, $reply )
	{
		$place = __CLASS__ . '::' . __FUNCTION__;
		$wo->debug( "$place:  " );
	
		//TODO
		
		// Find the request in the table
		$friendRequest = $wo->db->getRow('voice_user_friend_requests', $requestId);
		if($friendRequest === FALSE) { return false; }
		if($friendRequest === NULL) {
			$wo->logError(self::_ECP."1355 No row with id [$requestId] found!");
			return false;
		}
		
		//If rejected then update status and statusdatetime
		if($reply === "R") {
			$tblFriendRequestUpdate = new VO_TblUserFriendRequests($friendRequest);
			
			$tblFriendRequestUpdate->status = $reply;
			$tblFriendRequestUpdate->statusDateTime = WOOOF::currentGMTDateTime();
			
			$res = self::saveUserFriendRequests($wo, $tblFriendRequestUpdate);
			if($res === FALSE) { return false; }
		}
		
		//If request accepted then delete the friend request row and update the voice_user_friendships table
		else if($reply === "A") {
			//update the friendships table add it there as friendship
			$tblFriendshipsInsert = new VO_TblUserFriendships();
			$tblFriendshipsInsert->thisId = $friendRequest['fromUserId'];
			$tblFriendshipsInsert->isFriendsWithId = $friendRequest['toUserId'];
			
			$friendInsert = self::saveUserFriendships($wo, $tblFriendshipsInsert);
			if($friendInsert === FALSE) { return false; }
			
			//delete the request from friend_requests table
			$deleteReq = self::deleteUserFriendRequests($wo, $requestId, false );
			if($deleteReq === FALSE) { return false; }
		}
		else {
			$wo->logError(self::_ECP."1357 Unknown reply type [$reply]");
			return false;
		}
		
		$usActId = VO_Users::saveAction( $wo,
			( $reply == 'A' ? 'FR2' : 'FR3' ), $friendRequest['fromUserId'],
			null, null, $friendRequest['toUserId']
		);

		return $reply;
		
	}	// userAnswerFriendShip
	
	/***************************************************************************/
	//
	/***************************************************************************/
	
	/**
	 *
	 * @param WOOOF $wo
	 * @param id $fromUserId
	 * @param id $toUserId
	 * @return false | id
	 * Returns actually saved $obj if $fetchBack is set to true
	 */
	public static
	function userDeleteFriendShip( WOOOF $wo, $fromUserId, $toUserId )
	{
		$place = __CLASS__ . '::' . __FUNCTION__;
		$wo->debug( "$place:  " );
	
		//Find the ID you want to delete
		$sql =  "select id ";
		$sql .=	"from voice_user_friendships ";
		$sql .= "where thisId = '$fromUserId' and isFriendsWithId = '$toUserId' or thisId = '$toUserId' and isFriendsWithId = '$fromUserId' ";
	
		$deleteFriendShip = $wo->db->getResultByQuery($sql, true, false);
		if ( $deleteFriendShip === FALSE ) { return FALSE; }
	
		$deleteFriendShip = $wo->db->resultRows;
	
		foreach( $deleteFriendShip as $aRow ) {
			$res = self::deleteUserFriendships($wo, $aRow['id']);
			if($res === FALSE) { return false; }
		}
	
		return $res;
	
	}	// userDeleteFriendShip
	
	/***************************************************************************/
	//
	/***************************************************************************/
	
	/**
	 *
	 * @param WOOOF $wo
	 * @param id $fromUserId
	 * @param id $toUserId
	 * @return false | id
	 * Returns actually saved $obj if $fetchBack is set to true
	 */
	public static
	function userBookmarks( WOOOF $wo, $fromUserId, $toUserId, $targetType='PRS' )
	{
		$place = __CLASS__ . '::' . __FUNCTION__;
		$wo->debug( "$place:  " );
	
		$tblUserBookmarkInsert = new VO_TblUserBookmarks();
		$tblUserBookmarkInsert->voiceUserId = $fromUserId;
		$tblUserBookmarkInsert->thisId = $toUserId;
		$tblUserBookmarkInsert->targetType = $targetType;
	
		$res = self::saveUserBookmark($wo, $tblUserBookmarkInsert);
		if($res === FALSE) { return false; }
	
		return $res;
	
	}	// userBookmarks
	
	/***************************************************************************/
	//
	/***************************************************************************/
	
	/**
	 *
	 * @param WOOOF $wo
	 * @param id $fromUserId
	 * @param id $toUserId
	 * @return false | unbookmarked object type
	 * Returns actually saved $obj if $fetchBack is set to true
	 */
	public static
	function userUnBookmarks( WOOOF $wo, $fromUserId, $toUserId )
	{
		$place = __CLASS__ . '::' . __FUNCTION__;
		$wo->debug( "$place:  " );
	
		//Find the ID you want to delete
		$sql =  "select id, targetType ";
		$sql .=	"from voice_user_bookmarks ";
		$sql .= "where voiceUserId = '$fromUserId' and thisId = '$toUserId' ";
	
		$deleteRow = $wo->db->getResultByQuery($sql, true, false);
		if ( $deleteRow === FALSE ) { return FALSE; }
	
		$deleteRow = $wo->db->resultRows;
	
		foreach( $deleteRow as $aRow ) {
			$unBookmarkedObjType = $aRow['targetType'];
			$res = self::deleteUserBookmark($wo, $aRow['id']);
			if($res === FALSE) { return false; }
		}
	
		return $unBookmarkedObjType;
	
	}	// userUnBookmarks
	
	/***************************************************************************/
	//
	/***************************************************************************/
	
	/**
	 *
	 * @param WOOOF $wo
	 * @return false | array[ ]
	 */
	public static
	function getBookmarks( WOOOF $wo )
	{
		$place = __CLASS__ . '::' . __FUNCTION__;
		$wo->debug( "$place: Bookmarks Page" );
	
		if ( $wo->userData['id'] == '0123456789' ) {
			$wo->handleShowStopperError('505');
		}
	
		$bookmarks = []; //array to be sent to react element
		$bookmarkElems = ['id', 'createdDateTime', 'voiceUserId', 'thisId', 'targetType'];
	
		$voiceUserBookmarks = new WOOOF_dataBaseTable($wo->db, 'voice_user_bookmarks');
		if ( !$voiceUserBookmarks->constructedOk ) { return false; }
	
		$res = $voiceUserBookmarks->getResult(
			[
				'voiceUserId' => $wo->app->userId
			],
			'createdDateTime',
			'', '', '',
			true, false
		);
		if ( $res === FALSE ) { return false; }
	
		if ( $res['totalRows'] != 0 ) {
			foreach($voiceUserBookmarks->resultRows as $v_bookmark) {
				$bookmark = [];
				WOOOF_Util::filterOnKeys($bookmark, $bookmarkElems, $v_bookmark);
				array_push($bookmarks, $bookmark);
			}
		}
	
		if ( $res['totalRows'] == 0 ) {
			return NULL;
		}

		return $bookmarks;
	} //getBookmarks
	
	/***************************************************************************/
	//
	/***************************************************************************/
	
	/**
	 *
	 * @param WOOOF $wo
	 * @param id $voiceUserId
	 * @return false | array[ ]
	 */
	public static
	function getFollowers( WOOOF $wo, $voiceUserId )
	{
		$place = __CLASS__ . '::' . __FUNCTION__;
		$wo->debug( "$place:  $voiceUserId" );
		
		if ( $wo->userData['id'] == '0123456789' ) {
			$wo->handleShowStopperError('505');
		}
		
		if(!$wo->hasContent($voiceUserId)) {
			$wo->logError(self::_ECP."2222 You must provide a [voiceUserId]");
			return false;
		}
		
		$followers = []; //array to be sent to react element
		$followerElems = ['id', 'createdDateTime', 'followsId', 'thisId', 'isPeer', 'targetType'];
	
		$voiceUserFollowers = new WOOOF_dataBaseTable($wo->db, 'voice_user_followings');
		if ( !$voiceUserFollowers->constructedOk ) { return false; }
	
		$res = $voiceUserFollowers->getResult(
			[
				'thisId' => $voiceUserId
			],
			'createdDateTime',
			'', '', '',
			true, false
		);
		if ( $res === FALSE ) { return false; }
	
		if ( $res['totalRows'] != 0 ) {
			foreach($voiceUserFollowers->resultRows as $v_follower) {
				$follower = [];
				WOOOF_Util::filterOnKeys($follower, $followerElems, $v_follower);
				array_push($followers, $follower);
			}
		}
		
		if ( $res['totalRows'] == 0 ) {
			return NULL;
		}
	
		return $followers;
	} //getFollowers
	
	/***************************************************************************/
	//
	/***************************************************************************/
	
	/**
	 *
	 * @param WOOOF $wo
	 * @param id $voiceUserId
	 * @return false | array[ ]
	 */
	public static
	function getFollowings( WOOOF $wo, $voiceUserId )
	{
		$place = __CLASS__ . '::' . __FUNCTION__;
		$wo->debug( "$place:  $voiceUserId" );
		
		if ( $wo->userData['id'] == '0123456789' ) {
			$wo->handleShowStopperError('505');
		}
	
		if(!$wo->hasContent($voiceUserId)) {
			$wo->logError(self::_ECP."2223 You must provide a [voiceUserId]");
			return false;
		}
		
		$followings = []; //array to be sent to react element
		$followingElems = ['id', 'createdDateTime', 'followsId', 'thisId', 'isPeer', 'targetType'];
	
		$voiceUserFollowings = new WOOOF_dataBaseTable($wo->db, 'voice_user_followings');
		if ( !$voiceUserFollowings->constructedOk ) { return false; }
	
		$res = $voiceUserFollowings->getResult(
			[
				'followsId' => $voiceUserId
			],
			'createdDateTime',
			'', '', '',
			true, false
		);
		if ( $res === FALSE ) { return false; }
		
		if ( $res['totalRows'] != 0 ) {
			foreach($voiceUserFollowings->resultRows as $v_following) {
				$following = [];
				WOOOF_Util::filterOnKeys($following, $followingElems, $v_following);
				array_push($followings, $following);
			}
		}
		
		if ( $res['totalRows'] == 0 ) {
			return NULL;
		}

		return $followings;
	} //getFollowings
	
	/***************************************************************************/
	//
	/***************************************************************************/
	
	/**
	 *
	 * @param WOOOF $wo
	 * @param id $voiceUserId
	 * @return false | array[ ]
	 */
	public static
	function getPeers( WOOOF $wo, $voiceUserId )
	{
		$place = __CLASS__ . '::' . __FUNCTION__;
		$wo->debug( "$place:  $voiceUserId" );
		
		if ( $wo->userData['id'] == '0123456789' ) {
			$wo->handleShowStopperError('505');
		}
		
		if(!$wo->hasContent($voiceUserId)) {
			$wo->logError(self::_ECP."2224 You must provide a [voiceUserId]");
			return false;
		}
	
		$peers = []; //array to be sent to react element
		$peerElems = ['id', 'createdDateTime', 'followsId', 'thisId', 'isPeer'];
	
		$voiceUserPeers = new WOOOF_dataBaseTable($wo->db, 'voice_user_followings');
		if ( !$voiceUserPeers->constructedOk ) { return false; }
	
		$res = $voiceUserPeers->getResult(
			[
				'followsId' => $voiceUserId,
				'isPeer'	=> '1'
			],
			'createdDateTime',
			'', '', '',
			true, false
		);
		if ( $res === FALSE ) { return false; }
	
		if ( $res['totalRows'] != 0 ) {
			foreach($voiceUserPeers->resultRows as $v_peer) {
				$peer = [];
				WOOOF_Util::filterOnKeys($peer, $peerElems, $v_peer);
				array_push($peers, $peer);
			}
		}
		
		if ( $res['totalRows'] == 0 ) {
			return NULL;
		}
	
		return $peers;
	} //getPeers
	
	/***************************************************************************/
	//
	/***************************************************************************/
	
	/**
	 *
	 * @param WOOOF $wo
	 * @param id $voiceUserId
	 * @return false | array[ ]
	 */
	public static
	function getFriends( WOOOF $wo, $voiceUserId )
	{
		$place = __CLASS__ . '::' . __FUNCTION__;
		$wo->debug( "$place:  $voiceUserId" );
		
		if ( $wo->userData['id'] == '0123456789' ) {
			$wo->handleShowStopperError('505');
		}
		
		if(!$wo->hasContent($voiceUserId)) {
			$wo->logError(self::_ECP."2225 You must provide a [voiceUserId]");
			return false;
		}
	
		$friends = []; //array to be sent to react element
		$friendElems = ['id', 'createdDateTime', 'thisId', 'isFriendsWithId'];
	
		$voiceUserFriends = new WOOOF_dataBaseTable($wo->db, 'voice_user_friendships');
		if ( !$voiceUserFriends->constructedOk ) { return false; }
	
		$sql =  "select * ";
		$sql .=	"from voice_user_friendships ";
		$sql .= "where thisId = '$voiceUserId' or isFriendsWithId = '$voiceUserId' ";
		
		$friendRows = $wo->db->query($sql);
		
		if ( $friendRows === FALSE ) { return FALSE; }
		
		if (!$wo->db->getNumRows($friendRows))
		{
			//no error no results
			return 0;
		}
		else
		{
			//no error with results
			while($row = $wo->db->fetchAssoc($friendRows))
			{
				$friendRows->resultRows[] = $row;
			}
		}
		
		foreach( $friendRows as $aFriendRow ) {
			$friend = [];
			WOOOF_Util::filterOnKeys($friend, $friendElems, $aFriendRow);
			array_push($friends, $friend);
		}
	
		return $friends;
	} //getFriends
	
	/***************************************************************************/
	//
	/***************************************************************************/
	
	/**
	 *
	 * @param WOOOF $wo
	 * @param id $voiceUserId
	 * @return false | array[ ]
	 */
	public static
	function getFriendRequests( WOOOF $wo, $voiceUserId )
	{
		$place = __CLASS__ . '::' . __FUNCTION__;
		$wo->debug( "$place:  $voiceUserId" );
	
		if ( $wo->userData['id'] == '0123456789' ) {
			$wo->handleShowStopperError('505');
		}
	
		if(!$wo->hasContent($voiceUserId)) {
			$wo->logError(self::_ECP."2227 You must provide a [voiceUserId]");
			return false;
		}
	
		$friendRequests = []; //array to be sent to react element
		$friendRequestElems = ['id', 'statusDateTime', 'fromUserId', 'toUserId', 'status'];
	
		$voiceUserFriendRequests = new WOOOF_dataBaseTable($wo->db, 'voice_user_friend_requests');
		if ( !$voiceUserFriendRequests->constructedOk ) { return false; }
	
		$sql =  "select * ";
		$sql .=	"from voice_user_friend_requests ";
		$sql .= "where (fromUserId = '$voiceUserId' or toUserId = '$voiceUserId') and status = 'P' ";
	
		$friendRequestRows = $wo->db->query($sql);
	
		if ( $friendRequestRows === FALSE ) { return FALSE; }
	
		if (!$wo->db->getNumRows($friendRequestRows))
		{
			//no error no results
			return 0;
		}
		else
		{
			//no error with results
			while($row = $wo->db->fetchAssoc($friendRequestRows))
			{
				$friendRequestRows->resultRows[] = $row;
			}
		}
	
		foreach( $friendRequestRows as $aFriendRequest ) {
			$friendRequest = [];
			WOOOF_Util::filterOnKeys($friendRequest, $friendRequestElems, $aFriendRequest);
			array_push($friendRequests, $friendRequest);
		}
	
		return $friendRequests;
	} //getFriendRequests
	
	/***************************************************************************/
	//
	/***************************************************************************/
	
	/**
	 *
	 * @param WOOOF $wo
	 * @param id $requestorUserId
	 * @param array $targetIds
	 * @return false | array[ [id, targetType], ... , ]
	 */
	public static
	function getConnectionInfo( WOOOF $wo, $requestorUserId, $targetIds )
	{
		$place = __CLASS__ . '::' . __FUNCTION__;
		$wo->debug( "$place: [$requestorUserId]" );
	
		if ( $requestorUserId === NULL ) {
			// possible for API calls
			return [];
		}
		
		if(!$wo->hasContent($requestorUserId)) {
			$wo->logError(self::_ECP."2235 You must provide a [requestorUserId]");
			return false;
		}
		
		if(!$wo->hasContent($targetIds)) {
			$wo->logError(self::_ECP."2236 You must provide [targetIds]");
			return false;
		}
	
		$voiceUserFollowStats = new WOOOF_dataBaseTable($wo->db, 'voice_user_followings');
		if ( !$voiceUserFollowStats->constructedOk ) { return false; }
		
		$voiceUserBookmarkStats = new WOOOF_dataBaseTable($wo->db, 'voice_user_bookmarks');
		if ( !$voiceUserBookmarkStats->constructedOk ) { return false; }
		
		$voiceUserFriendStats = new WOOOF_dataBaseTable($wo->db, 'voice_user_friendships');
		if ( !$voiceUserFriendStats->constructedOk ) { return false; }
		
		$voiceUserFriendRequestsStats = new WOOOF_dataBaseTable($wo->db, 'voice_user_friend_requests');
		if ( !$voiceUserFriendRequestsStats->constructedOk ) { return false; }
	
		$statuses = [];
		
		foreach ($targetIds as $aTarget) {
			$status = [];
			$targetId 	= $aTarget[0];
			$targetType = $aTarget[1];
			
			if ( $targetId == $requestorUserId && $targetType == 'PRS' ) {
				// Add these to satisfy the frontend.
				$status = [ 'targetId'=> $targetId, 'followStatus' => 'N' ];
				$statuses[$targetId] = $status;
				continue;
			}
				
			// BUILD followStatus array
			
			// First check if the requestor follows the target entity
			$follower = $voiceUserFollowStats->getResult(
				[
					'followsId'  => $requestorUserId,
					'thisId'	 => $targetId,
					'targetType' => $targetType
				],
				'', '', '', '', false, true
			);
			if ( $follower === FALSE ) { return false; }
			$requestorFollowsTarget = $follower['totalRows'] != 0;
			
			// Then check if the target entity (PRS) follows the requestor
			if ( $targetType == 'PRS' ) {
				$following = $voiceUserFollowStats->getResult(
					[
						'followsId' => $targetId,
						'thisId'	=> $requestorUserId,
						'targetType' => $targetType
					],
					'', '', '', '', false, true
				);
				if ( $following === FALSE ) { return false; }
				$targetFollowingRequestor = $following['totalRows'] != 0;
			}
			else {
				$targetFollowingRequestor = false;
			}
			
			//none follows anyone
			if(!$requestorFollowsTarget && !$targetFollowingRequestor) {
				$status['followStatus'] = 'N';
				$status['followLink'] = 'api/social/followUser/'.$targetId;
			}
			
			//requestor does follow target
			else if($requestorFollowsTarget && !$targetFollowingRequestor) {
				$status['followStatus'] = 'F1';
				$status['followLink'] = 'api/social/unFollowUser/'.$targetId;
			}
			
			//target follows requestor
			else if(!$requestorFollowsTarget && $targetFollowingRequestor) {
				$status['followStatus'] = 'F2';
				$status['followLink'] = 'api/social/followUser/'.$targetId;
			}
			
			//peers
			else if($requestorFollowsTarget && $targetFollowingRequestor) {
				$status['followStatus'] = 'P';
				$status['followLink'] = 'api/social/unFollowUser/'.$targetId;
			}
			
			// BUILD bookmarkStatus array
				
			// First check if the requestor has already bookmarked the target entity
			$bookmarker = $voiceUserBookmarkStats->getResult(
				[
					'voiceUserId'	=> $requestorUserId,
					'thisId'		=> $targetId,
					'targetType' 	=> $targetType
				],
				'', '', '', '', true, false
			);
			if ( $bookmarker === FALSE ) { return false; }
			$requestorBookmarksTarget = $bookmarker['totalRows'] != 0;
				
			// Then check if the target user has already bookmarked the requestor
			// TODO: This looks wrong (not useful)!
			/*
			$bookmarking = $voiceUserBookmarkStats->getResult(
				[
					'voiceUserId' => $targetId,
					'thisId'	=> $requestorUserId,
					'targetType' => $targetType
				],
				'', '', '', '', false, true
			);
			if ( $bookmarking === FALSE ) { return false; }
			$targetBookmarkingRequestor = $bookmarking['totalRows'] != 0;
			*/
			//$targetBookmarkingRequestor = false;
			
			//noone bookmarks anyone
			if(!$requestorBookmarksTarget ) {
				$status['bookmarkStatus'] = 'N';
				$status['bookmarkLink'] = 'api/social/bookmark/'.$targetType.'/'.$targetId;
			}
				
			//requestor does bookmark target
			else {/*if($requestorBookmarksTarget && !$targetBookmarkingRequestor) {*/
				$bId = $voiceUserBookmarkStats->resultRows[0]['id'];
				$status['bookmarkStatus'] = 'B1';
				$status['bookmarkLink'] = 'api/social/unBookmark/'.$bId;
			}
			/*	
			//target bookmarks requestor
			else if(!$requestorBookmarksTarget && $targetBookmarkingRequestor) {
				$status['bookmarkStatus'] = 'B2';
				$status['bookmarkLink'] = 'api/social/bookmarkUser/'.$targetId;
			}
				
			//peers
			else if($requestorBookmarksTarget && $targetBookmarkingRequestor) {
				$status['bookmarkStatus'] = 'P';
				$status['bookmarkLink'] = 'api/social/unBookmarkUser/'.$targetId;
			}
			*/
			
			// BUILD friendStatus array
				
			// First check if the requestor is friend with the targetId
			if ( $targetType == 'PRS' ) {
				$sql =  "select id ";
				$sql .=	"from voice_user_friendships ";
				$sql .= "where (thisId = '$requestorUserId' and isFriendsWithId = '$targetId') or (thisId = '$targetId' and isFriendsWithId = '$requestorUserId') ";
				
				$rows = $wo->db->getResultByQuery($sql, true, false);
				if ( $rows === FALSE ) { return FALSE; }
				
				$rows = $wo->db->resultRows;
				
				$isFriendsWith = $wo->hasContent($rows);
				
				//Then check for any friend requests between them
				$madeRequest = $voiceUserFriendRequestsStats->getResult(
					[
						'fromUserId' => $requestorUserId,
						'toUserId'	 => $targetId,
						'status'	 => 'P'
					],
					'', '', '', '', false, true
				);
					
				if ( $madeRequest === FALSE ) { return false; }
					
				$requestorFriendedTarget = $madeRequest['totalRows'] != 0;
				
				foreach( $voiceUserFriendRequestsStats->resultRows as $aRow ) {
					$status['madefriendRequestId'] = $aRow['id'];
				}
				
				$gotRequested = $voiceUserFriendRequestsStats->getResult(
					[
						'fromUserId' => $targetId,
						'toUserId'	=> $requestorUserId,
						'status'	 => 'P'
					],
					'', '', '', '', false, true
				);
				
				if ( $gotRequested === FALSE ) { return false; }
				
				$targetFriendedRequestor = $gotRequested['totalRows'] != 0;
				
				foreach( $voiceUserFriendRequestsStats->resultRows as $aRow ) {
					$status['gotfriendRequestId'] = $aRow['id'];
				}
				
				//they are friends
				if($isFriendsWith) {
					$status['friendStatus'] = 'Y';
					$status['friendLink'] = 'api/social/deleteFriendship/'.$targetId;
				}
				
				else {
					//no friends - no requests
					if(!$requestorFriendedTarget && !$targetFriendedRequestor) {
						$status['friendStatus'] = 'N';
						$status['friendLink'] = 'api/social/requestFriendship/'.$targetId;
					}
					
					//requestor did a pending requested
					else if($requestorFriendedTarget && !$targetFriendedRequestor) {
						$status['friendStatus'] = 'R1';
						$status['friendLink'] = 'api/social/resetFriendRequest/'.$status['madefriendRequestId'];
					}
					
					//target did a friend request to the requestor
					else if(!$requestorFriendedTarget && $targetFriendedRequestor) {
						$status['friendStatus'] = 'R2';
						$status['friendLinkAccept'] = 'api/social/answerFriendship/'.$status['gotfriendRequestId'].'/A';
						$status['friendLinkReject'] = 'api/social/answerFriendship/'.$status['gotfriendRequestId'].'/R';
					}	// requests...	
				}	// friends or not
			}	// targetType == PRS
			
			$status['targetId'] = $targetId;
			$statuses[$targetId] = $status;
		}
	
		return $statuses;
	} //getConnectionInfo
	
	/***************************************************************************/
	//
	/***************************************************************************/
	
	/**
	 *
	 * @param WOOOF $wo
	 * @param id $postBoxId
	 * @return false | array[ [ 'userId' =>, 'postBoxId' => ], ...  ]
	 */
	public static
	function getPostBoxesForPostPropagation( WOOOF $wo, $postBoxId )
	{
		// 4600
		
		$place = __CLASS__ . '::' . __FUNCTION__;
		$wo->debug( "$place:  $postBoxId" );
	
		if ( $wo->userData['id'] == '0123456789' ) {
			$wo->handleShowStopperError('505');
		}
	
		if(!$wo->hasContent($postBoxId)) {
			$wo->logError(self::_ECP."4600 You must provide [postBoxId]");
			return false;
		}
		
		// TODO: Return real results!!
		
		$pbRow = $wo->db->getRow( 'post_boxes', $postBoxId );
		if ( $pbRow === FALSE ) { return FALSE; }
		if ( $pbRow === NULL ) {
			$wo->logError(self::_ECP."4610 post_box with id [$postBoxId] was not found");
			return false;
		}
		
		$whatType	= $pbRow['ownerType'];
		$whatId		= $pbRow['ownerId'];
		
		$out = [];
		
		// Get Followers
		//
		$sql = "
			select
				vuf.followsId userId, pb.id postBoxId
			from
				voice_user_followings vuf,
				post_boxes pb
			where
				vuf.thisId = '$whatId' and
				vuf.targetType = '$whatType' and
				vuf.isDeleted = '0' and
				pb.ownerId = vuf.followsId and
				pb.ownerType = 'PRS'
		";
		
		$res = $wo->db->getResultByQuery( $sql, true, false );
		if ( $res === FALSE ) { return FALSE; }
		
		foreach( $wo->db->resultRows as $aRes ) {
			$out[$aRes['postBoxId']] = $aRes;
		}
		
		
		if ( $whatType == 'GRO' or $whatType == 'IDE' ) {
			$groupId = $whatId;
			if ( $whatType == 'IDE' ) {
				// Find Idea's Owners group
				$groupId = $wo->db->getSingleValueResult( $sql );
				if ( $groupId === FALSE ) { return FALSE; }
			}
			
			// Get Group Members
			$sql = "
				select
					vug.voiceUserId userId, pb.id postBoxId
				from
					voice_user_groups vug,
					post_boxes pb
				where
					vug.groupId = '$groupId' and
					vug.isDeleted = '0' and vug.isActive = '1' and
					pb.ownerId = vug.voiceUserId and
					pb.ownerType = 'PRS'
			";

			$res = $wo->db->getResultByQuery( $sql, true, false );
			if ( $res === FALSE ) { return FALSE; }
			
			foreach( $wo->db->resultRows as $aRes ) {
				$out[$aRes['postBoxId']] = $aRes;
			}
		}	// GRO
		
					
		if ( $whatType == 'ORG' ) {
			// Get User registered for the Org
			$sql = "
				select
					vu.id userId, pb.id postBoxId
				from
					voice_users vu,
					post_boxes pb
				where
					vu.organisationId = '$whatId' and
					pb.ownerId = vu.id and
					pb.ownerType = 'PRS'
			";
		
			$res = $wo->db->getResultByQuery( $sql, true, false );
			if ( $res === FALSE ) { return FALSE; }
					
			foreach( $wo->db->resultRows as $aRes ) {
				$out[$aRes['postBoxId']] = $aRes;
			}
		}	// ORG
		
		return $out;

		/*
		return [
			[ 'userId' => 'lJgKsDk49N', 'postBoxId' => 'lJgKsDk49N' ],
			[ 'userId' => 'Rw0xTyLrXl', 'postBoxId' => '1122334455' ],
			[ 'userId' => 'zMAtSgZSEM', 'postBoxId' => 'a1' ],
		];
		*/
	
	}	// getPostBoxesForPostPropagation
	
}	// VO_SOCIAL